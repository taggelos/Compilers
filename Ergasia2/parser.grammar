Package compiler;

Helpers
    sp = ' ';
    lf = 0x000a;
    cr = 0x000d;
    ff = 0x000c;
    ht = 0x0009; 
    line_terminator = lf | cr | cr lf;
    white_space = (sp | ht | ff | line_terminator)*;

    all = [0..0xffff];
    input_character = [all - [cr + lf]];

    digit = ['0' .. '9'];

    hexdig = digit | ['a' .. 'f'] | ['A' .. 'F'];
    hexcode = hexdig hexdig;

    escape_seq = '\n' | '\t' | '\r' | '\0'  | '\\' | '\' ''' | '\"' | '\x' hexcode;

    latin_letter = ['a' .. 'z'] | ['A' .. 'Z']; 

    char_literal = ' ' | '!' | '#' | '$' | '%' | '&' | '(' | ')' 
        | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' 
        | '?' | '@' | '[' | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~'
        | latin_letter | digit | escape_seq;

    not_dollar = [all - '$'];

    simple_comment = '$' (not_dollar input_character*)? line_terminator?;
    multi_comment = '$$' ('$'? not_dollar)* '$$';

Tokens
    white_space = white_space;
    escape_seq = escape_seq;
    comment = simple_comment | multi_comment;

    and     = 'and'; 
    char    = 'char';
    div     = 'div';
    do      = 'do';
    else    = 'else';
    fun     = 'fun';
    if      = 'if';
    int     = 'int';
    mod     = 'mod';
    not     = 'not';
    nothing = 'nothing';
    or      = 'or';
    ref     = 'ref';
    return  = 'return';
    then    = 'then';
    var     = 'var';
    while   = 'while';

    identifier = latin_letter (latin_letter | digit | '_' )*;

    integers = digit+;

    char_const = ''' char_literal ''';

    string_literal = '"' char_literal* '"';


    //operators

    minus   = '-';
    plus    = '+';
    star    = '*';
    neq     = '#';
    eq      = '=';
    lt      = '<';
    gt      = '>';
    lteq    = '<=';
    gteq    = '>=';

    //separators

    l_par   = '(';
    r_par   = ')';
    l_br    = '[';
    r_br    = ']';
    l_ag    = '{';
    r_ag    = '}';
    comma   = ',';
    semi    = ';';
    colon   = ':';
    arrow   = '<-';

Ignored Tokens
    white_space,
    comment;

Productions
    program = fun_def;

    fun_def =
        header local_def* block;

    header =
        fun identifier l_par fpar_def r_par colon return_type;

    fpar_def =
        {simple_par} ref? identifier colon types |
        {mult_par} ref? identifier comma fpar_def |
        {mult_types} ref? identifier colon types comma fpar_def |
        {semi_par} ref? identifier colon types semi fpar_def |
        {none} ;

    data_types =
        {int} int |
        {char} char;

    array_types =
        {brackets} l_br integers? r_br;

    types =
        {simple} data_types |
        {array} data_types array_types+;

    return_type =
        {simple} data_types |
        {none} nothing;

    local_def =
        {fun} fun_def |
        {dec} fun_dec |
        {var} var_def;

    fun_dec =
        header semi;

    block {-> stmt*} =
        l_ag stmt* r_ag {-> New stmt.block([stmt])};  //<--

    stmt =
        {semi} semi {-> []} |
        {assignment} assignment {-> [assignment.stmt]} |
        {block} block {-> [block.stmt]} | 
        {fun_cal} fun_cal semi {-> [fun_cal.stmt]} | 
        {ifstmt} ifstmt {-> [ifstmt.stmt]} |
        {whilestmt} whilestmt {-> [whilestmt.stmt]} | 
        {returnstmt} returnstmt {-> [returnstmt.stmt]};

    assignment {-> stmt} =  //<--
        l_val arrow expr semi {-> New stmt.assignment(l_val, expr)};

    l_val =
        {id} identifier | 
        {string} string_literal | 
        {id_brackets} l_val l_br expr r_br;

    fun_cal =
        identifier l_par expr_list r_par;

    expr_list {-> expr*} =
        {simple} expr {-> expr} |
        {list} expr_list comma expr {-> [expr_list.expr, expr]} |
        {none} ; 

    var_def =
        var var_ids colon types semi {-> New([var_ids.identifier], types)};

    var_ids {-> identifier*} =
        {id} identifier {-> [identifier]} |
        {list} identifier comma var_ids {-> [identifier, var_ids.identifier]};

    /* ----------------- IF & WHILE  ---------------------- */

    whilestmt {-> stmt} =
        while cond do stmt {-> New stmt.whilestmt([stmt.stmt])};

    while_with_else {-> stmt} =
        while cond do stmt_with_else {-> New stmt.whilestmt([stmt_with_else.stmt])};

    ifstmt {-> stmt*} =
        if_header if_trail ;

    if_header =
        if cond then;

    if_trail {-> stmt} =
        {no_else} [then]:stmt {-> New stmt.ifstmt([then.stmt], [])} | 
        {with_else} [then]:stmt_with_else else [else_st]:stmt {-> New stmt.ifstmt([then.stmt], [else_st.stmt])};

    stmt_with_else {-> stmt*} =
        {semi} semi {-> []} | 
        {assignment} assignment {-> [assignment.stmt]} | 
        {stmt_returnstmt} returnstmt {-> [returnstmt.stmt]} |
        {stmt_funcal} fun_cal semi {-> [fun_cal.stmt]} |
        {block} block {-> [block.stmt]} | 
        {if} if_else {-> [if_else.stmt]} | 
        {while} while_with_else {-> [while_with_else.stmt]};

    if_else {-> stmt} =
        if_header [then]:stmt_with_else else [else_st]:stmt_with_else 
        {-> New stmt.ifstmt([then.stmt], [else_st.stmt])};

    /* ---------------------------------------------------- */

    /* ----------------- CONDITION  ---------------------- */

    cond =
        {cond_and} conditional_and_expression |
        {or_expr} [left]:cond or [right]:conditional_and_expression;

    conditional_and_expression =
        {cond_not} conditional_not_expression |
        {and_expr} [left]:conditional_and_expression and [right]:conditional_not_expression;

    conditional_not_expression =
        {not_expr} not conditional_not_expression |
        {comparative} comparative_expression;

    comparative_expression =
        {relational} relational_expression |
        {equal} [left]:comparative_expression eq [right]:relational_expression |
        {not_equal} [left]:comparative_expression neq [right]:relational_expression ;

    relational_expression =
        {additive} expr |
        {less_than} [left]:relational_expression lt [right]:expr |
        {greater_than} [left]:relational_expression gt [right]:expr |
        {greater_equal_than} [left]:relational_expression gteq [right]:expr |
        {less_equal_than} [left]:relational_expression lteq [right]:expr ;

    /* ---------------------------------------------------- */

    returnstmt =
        {semi} return expr? semi;

    expr =
        {factor} factor {-> factor.expr} |
        {add} expr plus factor {-> New expr.plus(expr, factor.expr)} |
        {sub} expr minus factor {-> New expr.minus(expr, factor.expr)};

    factor {-> expr} =
        {term} term {-> term.expr} |
        {mult} factor star term {-> New expr.mult(factor.expr, term.expr)} |
        {mod} factor mod term {-> New expr.mod(factor.expr, term.expr)} |
        {div} factor div term {-> New expr.div(factor.expr, term.expr)};

    term {-> expr} =
        {plus_or_minus} plus_or_minus term {-> term.expr} |
        {int} integers {-> New expr.int(integers)} |
        {char} char_const |
        {l_val} l_val |
        {fun_cal} fun_cal |
        {par} l_par expr r_par {-> expr};

    plus_or_minus =
        {plus} plus | 
        {minus} minus;

Abstract Syntax Tree
    

    stmt = 
        {assignment} [name]:identifier assign [value]:expr | 
        {array_assign} [name]:identifier [index]:expr assign [value]:expr |
        {if} [then]:stmt* [else]:stmt* | 
        {while} [body]:stmt* |
        {block} [block]:stmt* | //<--
        {fun_cal} fun_cal | //<--
        {returnstmt} returnstmt;  //<--

    expr_list = [exprs]:expr*;

    expr = 
        {add} [expr1]:expr [expr2]:expr |
        {sub} [expr1]:expr [expr2]:expr |
        {mult} [expr1]:expr [expr2]:expr |
        {mod} [expr1]:expr [expr2]:expr |
        {div} [expr1]:expr [expr2]:expr |
        {int} integers |
        {char} char_const |  //<--
        {l_val} l_val |      //<--
        {fun_cal} fun_cal |  //<--
        {expr} expr;