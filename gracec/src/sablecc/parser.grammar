Package compiler;

Helpers
    sp = ' ';
    lf = 0x000a;
    cr = 0x000d;
    ff = 0x000c;
    ht = 0x0009; 
    line_terminator = lf | cr | cr lf;
    white_space = (sp | ht | ff | line_terminator)*;

    all = [0..0xffff];
    input_character = [all - [cr + lf]];

    digit = ['0' .. '9'];

    escape_seq = '\n' | '\t' | '\r' | '\0'  | '\\' | '\' ''' | '\"' | '\xnn'; //<--

    latin_letter = ['a' .. 'z'] | ['A' .. 'Z']; 

    char_literal = ' ' | '!' | '"' | '#' | '$' | '%' | '&' | '(' | ')' 
        | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' 
        | '?' | '@' | '[' | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~'
        | ['a' .. 'z'] | ['A' .. 'Z'] | digit | escape_seq;  //(escape_seq | ([_A-Za-z][_A-Za-z0-9])*)*

    not_dollar = [all - '$'];
    //not_doubledollar = [all - '$$'];

    simple_comment = '$' (not_dollar input_character*)? line_terminator?;
    //multi_comment = '$$' not_dollar* ('$' (not_dollar+))* '$$';
    multi_comment = '$$' ('$'? not_dollar)* '$$';

Tokens
    white_space = white_space;
    escape_seq = escape_seq;

    and     = 'and'; 
    char    = 'char';
    div     = 'div';
    do      = 'do';
    else    = 'else';
    fun     = 'fun';
    if      = 'if';
    int     = 'int';
    mod     = 'mod';
    not     = 'not';
    nothing = 'nothing';
    or      = 'or';
    ref     = 'ref';
    return  = 'return';
    then    = 'then';
    var     = 'var';
    while   = 'while';

    
    integers = digit+;

    string_literal = '"' char_literal* '"'; //<--
    char_const = '"' char_literal '"';

    identifier = latin_letter (latin_letter | digit | '_' )*;

    //operators

    minus   = '-';
    plus    = '+';
    star    = '*';
    slash   = '/';
    htag    = '#';
    eq      = '=';
    neq     = '<>';
    lt      = '<';
    gt      = '>';
    lteq    = '<=';
    gteq    = '>=';
    
  
    //separators

    l_par   = '(';
    r_par   = ')';
    l_br    = '[';
    r_br    = ']';
    l_ag    = '{';
    r_ag    = '}';
    comma   = ',';
    semi    = ';';
    colon   = ':';
    arrow   = '<-';  

    
    comment = simple_comment | multi_comment;


Ignored Tokens
    white_space,
    comment;


Productions
    /* program = line+;
    line = 
        {line1} expr | 
        {line2} var_def |
        {line3} fun_def;
    */
    program = fun_def;
    
    fun_def =
        {fun_def1} header local_def* block;

    header =
        {header1} fun identifier l_par fpar_def r_par colon return_type;

    fpar_def =
        {fpar_def1} ref? identifier colon types fpar_def |
        {fpar_def2} ref? identifier comma fpar_def |
        {fpar_def3} ref? identifier colon types comma fpar_def |
        {fpar_def4} semi fpar_def |
        {fpar_def5} ;

    data_types = 
        {data_types1} int |
        {data_types2} char;

    array_types =
        {array_types1} l_br integers? r_br;

    types =
        {types1} data_types |
        {types2} data_types array_types+;

    return_type =
        {return_type1} data_types |
        {return_type2} nothing;

    local_def =
        {local_def1} fun_def |
        {local_def2} fun_dec |
        {local_def3} var_def;

    fun_dec =
        {fun_dec} header semi;

    block =
        {block} l_ag stmt* r_ag;

    stmt =  
        {stmt1} semi | 
        {stmt2} l_val arrow expr semi |   //<---- assignment
        {stmt3} block | 
        {stmt4} fun_cal semi |
        {ifstmt} ifstmt | 
        {whilestmt} whilestmt |
        {returnstmt} returnstmt;

    assignment = 
        identifier arrow expr semi;

    l_val = 
        {l_val1} identifier | 
        {l_val2} string_literal | 
        {l_val3} identifier l_br expr r_br;  // Paizetai malakia

    fun_cal = 
        {fun_cal1} identifier l_par expr_list r_par;    
    
    expr_list =  
        {expr_list1} expr |
        {expr_list2} expr comma expr_list |
        {expr_list3} ; 

    var_def =
        {var_def1} var var_ids colon types semi;

    var_ids =
        {var_ids1} identifier |
        {var_ids2} identifier comma var_ids;

    whilestmt = 
        while cond do stmt ;        

    while_with_else = 
        while cond do stmt_with_else ;   

    ifstmt = 
        if_header if_trail ;
    
    if_header = 
        if cond then;
    
    if_trail  = 
        {no_else} [then]:stmt | 
        {with_else} [then]:stmt_with_else else [else_st]:stmt ;

    stmt_with_else = 
        {semi} semi | 
        {assignment} assignment | 
        {stmt_returnstmt} returnstmt |    
        {stmt_funcal} fun_cal semi |
        {block} block | 
        {if} if_else | 
        {while} while_with_else ;

    if_else = 
        if_header [then]:stmt_with_else else [else_st]:stmt_with_else ;

    cond =
        integers;


/*
    comparative_expression {-> expression} =
        {relational} expr |
        {equal} [left]:comparative_expression equal [right]:expr |
        {not_equal} [left]:comparative_expression not_equal [right]:expr |
        {additive} additive_expression |
        {less_than} [left]:expr less_than [right]:additive_expression |
        {greater_than} [left]:expr greater_than [right]:additive_expression |
        {greater_equal_than} [left]:expr greater_equal_than [right]:additive_expression |
        {less_equal_than} [left]:expr less_equal_than [right]:additive_expression;
*/


    returnstmt =
        {returnstmt1} return semi |
        {returnstmt2} return expr semi;
        
    expr =
        {expr1} factor |
        {expr2} expr plus factor |
        {expr3} expr minus factor |
        {expr4} l_val |        
        {expr5} fun_cal ;

    factor =
        {factor1} term |
        {factor2} factor star term |
        {factor3} factor slash term |
        {factor4} factor mod term;

    term =
        {term1} integers |
        {term2} char_const;
        //{term2} l_val | //pros suzhthsh
        //{term3} l_par expr r_par;

